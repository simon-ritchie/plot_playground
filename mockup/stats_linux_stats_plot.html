<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <script src="https://d3js.org/d3.v4.js"></script>
        <style>
            #test-svg {
                background-color: #333333;
            }

            #test-svg .font {
                font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", YuGothic, "ヒラギノ角ゴ ProN W3", Hiragino Kaku Gothic ProN, Arial, "メイリオ", Meiryo, sans-serif;
            }

            #test-svg .outer-border-rect {
                fill: none;
                stroke: #999999;
                stroke-width: 1px;
            }

            #test-svg .title {
                fill: #999999;
                font-size: 14px;
            }

            #test-svg .line {
                fill: none;
                stroke: #cccccc;
                stroke-width: 2.5;
            }

            #test-svg .axis text {
                fill: #999999;
                font-size: 14px;
            }

            #test-svg .axis line,
            #test-svg .axis path {
                fill: none;
                stroke: #999999;
                shape-rendering: crispEdges;
            }

            #test-svg .value-line {
                fill: none;
                stroke: #6bb2f8;
                stroke-width: 1.0;
            }
        </style>
    </head>
    <body>
        <script>
            const SVG_ID = "test-svg";
            const SVG_WIDTH = 700;
            const BASIC_MARGIN = 20;
            const PLOT_UNIT_HEIGHT = 200;
            const SVG_TOTAL_HEIGHT = PLOT_UNIT_HEIGHT * 4 + BASIC_MARGIN * 5;
            const PLOT_X = 1 + BASIC_MARGIN;
            const GPU_NUM = 2;
            const LOG_FILE_PATH = "./stats_linux_stats_plot_log.csv";
            const COLUMN_NAME_MEMORY_USAGE = "memory usage (MB)";
            const COLUMN_NAME_DISK_USAGE = "disk usage (GB)";
            const INTERVAL_SECONDS = 2;
            const AXIS_TICKS = 5;
            const ANIMATION_DURATION = 300;

            /**
             * Get the bounding box width of the target d3 element.
             *
             * @param {Object} elem: The target d3 element.
             *
             * @return {int} The bounding box width.
             */
            function getBBoxWidth(elem) {
                var bBox = elem.node()
                    .getBBox();
                return parseInt(bBox.width);
            }

            /**
             * Gets the column name of memory usage of the GPU.
             *
             * @param {int} gpuIndex: Index of target GPU (Starting
             * from zero).
             *
             * @return {String} GPU column name.
             */
            function getGPUColumnName(gpuIndex) {
                return "gpu(" + gpuIndex + ") memory usage (MB)";
            }

            var svg = d3.select("body").append('svg')
                .attr("width", SVG_WIDTH)
                .attr("height", SVG_TOTAL_HEIGHT)
                .attr("id", SVG_ID);

            const MEMORY_USAGE_PLOT_Y = 1 + BASIC_MARGIN;
            var memoryUsagePlotBorderRect = svg.append("rect")
                .attr("width", SVG_WIDTH - 2 - BASIC_MARGIN * 2)
                .attr("height", PLOT_UNIT_HEIGHT - 2)
                .classed("outer-border-rect", true)
                .attr("x", PLOT_X)
                .attr("y", 1 + BASIC_MARGIN);

            const DISK_USAGE_PLOT_Y = PLOT_UNIT_HEIGHT + BASIC_MARGIN * 2 + 1;
            var diskUsagePlotBorderRect = svg.append("rect")
                .attr("width", SVG_WIDTH - 2 - BASIC_MARGIN * 2)
                .attr("height", PLOT_UNIT_HEIGHT - 2)
                .classed("outer-border-rect", true)
                .attr("x", PLOT_X)
                .attr("y", DISK_USAGE_PLOT_Y);

            var gpuMemoryUsagePlotYList = [];
            for (var i = 0; i < GPU_NUM; i++) {
                var gpuMemoryUsagePlotY = PLOT_UNIT_HEIGHT * (2 + i) + BASIC_MARGIN * (3 + i) + 1;
                gpuMemoryUsagePlotYList.push(gpuMemoryUsagePlotY);
                svg.append("rect")
                    .attr("width", SVG_WIDTH - 2 - BASIC_MARGIN * 2)
                    .attr("height", PLOT_UNIT_HEIGHT - 2)
                    .classed("outer-border-rect", true)
                    .attr("x", PLOT_X)
                    .attr("y", gpuMemoryUsagePlotY);
            }

            var rowConverter = function(d) {
                var rowDict = {
                    memoryUsage: parseInt(d[COLUMN_NAME_MEMORY_USAGE]),
                    diskUsage: parseFloat(d[COLUMN_NAME_DISK_USAGE])
                };
                for (var i = 0; i < GPU_NUM; i++) {
                    var gpuColumnName = getGPUColumnName(gpuIndex=i);
                    rowDict["gpuMemoryUsage" + i] = parseInt(
                        d[gpuColumnName]);
                }
                return rowDict;
            }

            var memoryUsageYScale = d3.scaleLinear()
                .range([
                    MEMORY_USAGE_PLOT_Y + PLOT_UNIT_HEIGHT - 1 - BASIC_MARGIN,
                    MEMORY_USAGE_PLOT_Y + 1 + BASIC_MARGIN]);
            var memoryUsageAxis = d3.axisLeft()
                .ticks(AXIS_TICKS);
            var memoryUsageAxisGroup = svg.append("g")
                .classed("axis font", true);

            var diskUsageYScale = d3.scaleLinear()
                .range([
                    DISK_USAGE_PLOT_Y + PLOT_UNIT_HEIGHT - 1 - BASIC_MARGIN,
                    DISK_USAGE_PLOT_Y + 1 + BASIC_MARGIN]);
            var diskUsageAxis = d3.axisLeft()
                .ticks(AXIS_TICKS);
            var diskUsageAxisGroup = svg.append("g")
                .classed("axis font", true);

            var gpuMemoryUsageYScaleList = [];
            var gpuMemoryUsageAxisList = [];
            var gpuMemoryUsageAxisGroupList = [];
            for (var i = 0; i < GPU_NUM; i++) {
                gpuMemoryUsageYScaleList.push(
                    d3.scaleLinear()
                        .range([
                            gpuMemoryUsagePlotYList[i] + PLOT_UNIT_HEIGHT - 1 - BASIC_MARGIN,
                            gpuMemoryUsagePlotYList[i] + 1 + BASIC_MARGIN
                        ])
                );
                gpuMemoryUsageAxisList.push(
                    d3.axisLeft()
                        .ticks(AXIS_TICKS)
                );
                gpuMemoryUsageAxisGroupList.push(
                    svg.append("g")
                        .classed("axis font", true)
                );
            }

            var xScale = d3.scaleLinear();

            var memoryUsageLine = d3.line()
                .x(function(d, i) {
                    return xScale(i);
                })
                .y(function(d, i) {
                    return memoryUsageYScale(d.memoryUsage);
                });
            var memoryUsageLinePath = svg.append("path")
                .classed("value-line", true);

            var diskUsageLine = d3.line()
                .x(function(d, i) {
                    return xScale(i);
                })
                .y(function(d, i) {
                    return diskUsageYScale(d.diskUsage);
                });
            var diskUsageLinePath = svg.append("path")
                .classed("value-line", true);

            // var gpuMemoryUsageLineList = [];
            var gpuMemoryUsageLinePathList = [];
            for (var i = 0; i < GPU_NUM; i++) {
                // var gpuMemoryUsageLine = d3.line()
                //     .x(function(d, j) {
                //         return xScale(j);
                //     })
                //     .y(function(d, j) {
                //         var line = d3.select(this);
                //         var gpuIdx = parseInt(line.attr("gpu-index"));
                //         var gpuValue = d["gpuMemoryUsage" + gpuIdx];
                //         console.log("gpuIdx", gpuIdx);
                //         return gpuMemoryUsageYScaleList[gpuIdx](gpuValue);

                //     });
                // gpuMemoryUsageLine
                //     .attr("gpu-index", String(i));
                // gpuMemoryUsageLineList.push(gpuMemoryUsageLine);
                var gpuMemoryUsageLinePath = svg.append("path")
                    .classed("value-line", true);
                gpuMemoryUsageLinePathList.push(gpuMemoryUsageLinePath);
            }

            const DEFAULT_TITLE_X = PLOT_X + BASIC_MARGIN + 2;
            var memoryUsageTitle = svg.append("text")
                .attr("x", DEFAULT_TITLE_X)
                .attr("y", MEMORY_USAGE_PLOT_Y + 1 + BASIC_MARGIN)
                .text(COLUMN_NAME_MEMORY_USAGE)
                .attr("dominant-baseline", "hanging")
                .classed("title font", true);

            var diskUsageTitle = svg.append("text")
                .attr("x", DEFAULT_TITLE_X)
                .attr("y", DISK_USAGE_PLOT_Y + 1 + BASIC_MARGIN)
                .text(COLUMN_NAME_DISK_USAGE)
                .attr("dominant-baseline", "hanging")
                .classed("title font", true);

            var gpuMemoryUsageTitleList = [];
            for (var i = 0; i < GPU_NUM; i++) {
                var gpuColumnName = getGPUColumnName(i);
                gpuMemoryUsageTitleList.push(
                    svg.append("text")
                        .attr("x", DEFAULT_TITLE_X)
                        .attr("y", gpuMemoryUsagePlotYList[i] + 1 + BASIC_MARGIN)
                        .text(gpuColumnName)
                        .attr("dominant-baseline", "hanging")
                        .classed("title font", true)
                );
            }

            var isInitialUpdate = true;

            /**
             * Read the CSV and update the value of the plot.
             */
            function update_plot_value() {
                d3.csv(LOG_FILE_PATH, rowConverter, function(dataset) {
                    dataset = addRandomValueToDataset(dataset);
                    var memoryUsageMax = d3.max(dataset, function(d) {
                        return d.memoryUsage;
                    });
                    memoryUsageYScale.domain([0, memoryUsageMax]);
                    memoryUsageAxis.scale(memoryUsageYScale);
                    if (isInitialUpdate) {
                        memoryUsageAxisGroup.call(memoryUsageAxis);
                    }else {
                        memoryUsageAxisGroup
                            .transition()
                            .duration(ANIMATION_DURATION)
                            .call(memoryUsageAxis);
                    }
                    var bBoxWidth = getBBoxWidth(memoryUsageAxisGroup);
                    var memoryUsageAxisTransform = "translate(" + (bBoxWidth + BASIC_MARGIN * 2 + 1) + ", 0)";
                    if (isInitialUpdate) {
                        memoryUsageAxisGroup
                            .attr("transform", memoryUsageAxisTransform);
                    }else {
                        setTimeout(function() {
                            bBoxWidth = getBBoxWidth(memoryUsageAxisGroup);
                            var memoryUsageAxisTransform = "translate(" + (bBoxWidth + BASIC_MARGIN * 2 + 1) + ", 0)";
                            memoryUsageAxisGroup
                                .transition()
                                .duration(ANIMATION_DURATION)
                                .attr("transform", memoryUsageAxisTransform);
                        }, ANIMATION_DURATION + 10);
                    }

                    var diskUsageMax = d3.max(dataset, function(d) {
                        return d.diskUsage;
                    });
                    diskUsageYScale.domain([0, diskUsageMax]);
                    diskUsageAxis.scale(diskUsageYScale);
                    if (isInitialUpdate) {
                        diskUsageAxisGroup.call(diskUsageAxis);
                    }else {
                        diskUsageAxisGroup
                            .transition()
                            .duration(ANIMATION_DURATION)
                            .call(diskUsageAxis);
                    }
                    bBoxWidth = getBBoxWidth(diskUsageAxisGroup);
                    var diskUsageAxisTransform = "translate(" + (bBoxWidth + BASIC_MARGIN * 2 + 1) + ", 0)";
                    if (isInitialUpdate) {
                        diskUsageAxisGroup
                            .attr("transform", diskUsageAxisTransform);
                    }else {
                        setTimeout(function() {
                            bBoxWidth = getBBoxWidth(diskUsageAxisGroup);
                            var diskUsageAxisTransform = "translate(" + (bBoxWidth + BASIC_MARGIN * 2 + 1) + ", 0)";
                            diskUsageAxisGroup
                                .transition()
                                .duration(ANIMATION_DURATION)
                                .attr("transform", diskUsageAxisTransform);
                        }, ANIMATION_DURATION + 10);
                    }

                    for (var i = 0; i < GPU_NUM; i++) {
                        var gpuMemoryUsageMax = d3.max(dataset, function(d) {
                            return d["gpuMemoryUsage" + i];
                        });
                        gpuMemoryUsageYScaleList[i].domain(
                            [0, gpuMemoryUsageMax]);
                        gpuMemoryUsageAxisList[i].scale(
                            gpuMemoryUsageYScaleList[i])
                        if (isInitialUpdate) {
                            gpuMemoryUsageAxisGroupList[i].call(
                                gpuMemoryUsageAxisList[i]);
                        }else {
                            gpuMemoryUsageAxisGroupList[i]
                                .transition()
                                .duration(ANIMATION_DURATION)
                                .call(gpuMemoryUsageAxisList[i]);
                        }
                        if (isInitialUpdate) {
                            bBoxWidth = getBBoxWidth(gpuMemoryUsageAxisGroupList[i]);
                            gpuMemoryUsageAxisGroupList[i]
                                .attr("transform", "translate(" + (bBoxWidth + BASIC_MARGIN * 2 + 1) + ", 0)");
                        }else {
                            setTimeout(function() {
                                for (var i = 0; i < GPU_NUM; i++) {
                                    bBoxWidth = getBBoxWidth(gpuMemoryUsageAxisGroupList[i]);
                                    gpuMemoryUsageAxisGroupList[i]
                                        .transition()
                                        .duration(ANIMATION_DURATION)
                                        .attr("transform", "translate(" + (bBoxWidth + BASIC_MARGIN * 2 + 1) + ", 0)");
                                }
                            }, ANIMATION_DURATION + 10);
                        }
                    }

                    setTimeout(function() {
                        var axisBBoxWidthList = [
                            getBBoxWidth(memoryUsageAxisGroup),
                            getBBoxWidth(diskUsageAxisGroup)
                        ];
                        for (var i = 0; i < GPU_NUM; i++) {
                            axisBBoxWidthList.push(
                                getBBoxWidth(gpuMemoryUsageAxisGroupList[i])
                            );
                        }
                        var titleX = d3.max(axisBBoxWidthList) + PLOT_X + BASIC_MARGIN * 2;

                        memoryUsageTitle.transition()
                            .duration(ANIMATION_DURATION)
                            .attr("x", titleX);
                        diskUsageTitle.transition()
                            .duration(ANIMATION_DURATION)
                            .attr("x", titleX);
                        for (var i = 0; i < GPU_NUM; i++) {
                            gpuMemoryUsageTitleList[i].transition()
                                .duration(ANIMATION_DURATION)
                                .attr("x", titleX);
                        }

                        var datasetLen = dataset.length;
                        xScale.domain([0, datasetLen - 1])
                            .range([titleX, SVG_WIDTH - 1 - BASIC_MARGIN * 2]);

                        memoryUsageLinePath
                            .datum(dataset)
                            .transition()
                            .attr("d", memoryUsageLine);
                        diskUsageLinePath
                            .datum(dataset)
                            .transition()
                            .attr("d", diskUsageLine);
                        for (var i = 0; i < GPU_NUM; i++) {
                            var gpuMemoryUsageLine = d3.line()
                                .x(function(d, i) {
                                    return xScale(i);
                                })
                                .y(function(d) {
                                    var gpuValue = d["gpuMemoryUsage" + i];
                                    return gpuMemoryUsageYScaleList[i](gpuValue);
                                });
                            gpuMemoryUsageLinePathList[i]
                                .datum(dataset)
                                .transition()
                                .attr("d", gpuMemoryUsageLine);
                        }
                    }, ANIMATION_DURATION + 10);

                    isInitialUpdate = false;
                });
            }

            update_plot_value();
            setInterval(
                update_plot_value,
                INTERVAL_SECONDS * 1000);

            function addRandomValueToDataset(dataset) {
                var randomValue = Math.random() * 10000;
                for (var i = 0; i < dataset.length; i++) {
                    dataset[i]["memoryUsage"] += Math.random() * randomValue;
                }
                randomValue = Math.random() * 12;
                for (var i = 0; i < dataset.length; i++) {
                    dataset[i]["diskUsage"] += Math.random() * randomValue;
                }
                for (var i = 0; i < GPU_NUM; i++) {
                    randomValue = Math.random() * 15000;
                    for (var j = 0; j < dataset.length; j++) {
                        dataset[j]["gpuMemoryUsage" + i] += Math.random() * randomValue;
                    }
                }
                return dataset;
            }

        </script>
    </body>
</html>
